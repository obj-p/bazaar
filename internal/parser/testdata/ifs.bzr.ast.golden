&parser.Bazaar{
  Package: &parser.PackageDecl{
    Domain: []string{
      "ifs",
    },
  },
  Decls: []*parser.TopLevelDecl{
    {
      Function: &parser.FunctionDecl{
        Name: "Ifs",
        Parameters: []*parser.ParameterDecl{
          {
            Name: "foo",
            Type: &parser.TypeDecl{
              Value: &"bool",
            },
          },
          {
            Name: "bar",
            Type: &parser.TypeDecl{
              Value: &"bool",
            },
          },
          {
            Name: "baz",
            Type: &parser.TypeDecl{
              Value: &"bool",
              Optional: true,
            },
          },
        },
        Block: []*parser.Stmt{
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"foo",
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpNotEql),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"bar",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"foo",
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpEql),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"bar",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Binary: &parser.ControlBinaryExpr{
                            Left: &parser.ControlExpr{
                              Binary: &parser.ControlBinaryExpr{
                                Left: &parser.ControlExpr{
                                  Unary: &parser.ControlUnaryExpr{
                                    Primary: &parser.ControlPrimaryExpr{
                                      Reference: &parser.ControlReferenceExpr{
                                        Name: &"foo",
                                      },
                                    },
                                  },
                                },
                                Op: token.Op(token.OpEql),
                                Right: &parser.ControlExpr{
                                  Unary: &parser.ControlUnaryExpr{
                                    Primary: &parser.ControlPrimaryExpr{
                                      Reference: &parser.ControlReferenceExpr{
                                        Name: &"bar",
                                      },
                                    },
                                  },
                                },
                              },
                            },
                            Op: token.Op(token.OpAnd),
                            Right: &parser.ControlExpr{
                              Unary: &parser.ControlUnaryExpr{
                                Primary: &parser.ControlPrimaryExpr{
                                  Reference: &parser.ControlReferenceExpr{
                                    Name: &"foo",
                                  },
                                },
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpNotEql),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Literal: &parser.Literal{
                                Bool: &parser.Bool(true),
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Unary: &parser.ControlUnaryExpr{
                        Primary: &parser.ControlPrimaryExpr{
                          Nested: &parser.ControlExpr{
                            Binary: &parser.ControlBinaryExpr{
                              Left: &parser.ControlExpr{
                                Binary: &parser.ControlBinaryExpr{
                                  Left: &parser.ControlExpr{
                                    Unary: &parser.ControlUnaryExpr{
                                      Primary: &parser.ControlPrimaryExpr{
                                        Reference: &parser.ControlReferenceExpr{
                                          Name: &"foo",
                                        },
                                      },
                                    },
                                  },
                                  Op: token.Op(token.OpEql),
                                  Right: &parser.ControlExpr{
                                    Unary: &parser.ControlUnaryExpr{
                                      Primary: &parser.ControlPrimaryExpr{
                                        Reference: &parser.ControlReferenceExpr{
                                          Name: &"bar",
                                        },
                                      },
                                    },
                                  },
                                },
                              },
                              Op: token.Op(token.OpOr),
                              Right: &parser.ControlExpr{
                                Unary: &parser.ControlUnaryExpr{
                                  Primary: &parser.ControlPrimaryExpr{
                                    Nested: &parser.ControlExpr{
                                      Binary: &parser.ControlBinaryExpr{
                                        Left: &parser.ControlExpr{
                                          Unary: &parser.ControlUnaryExpr{
                                            Primary: &parser.ControlPrimaryExpr{
                                              Reference: &parser.ControlReferenceExpr{
                                                Name: &"foo",
                                              },
                                            },
                                          },
                                        },
                                        Op: token.Op(token.OpNotEql),
                                        Right: &parser.ControlExpr{
                                          Unary: &parser.ControlUnaryExpr{
                                            Primary: &parser.ControlPrimaryExpr{
                                              Literal: &parser.Literal{
                                                Bool: &parser.Bool(true),
                                              },
                                            },
                                          },
                                        },
                                      },
                                    },
                                  },
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Literal: &parser.Literal{
                                Bool: &parser.Bool(true),
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpOr),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Nested: &parser.ControlExpr{
                                Binary: &parser.ControlBinaryExpr{
                                  Left: &parser.ControlExpr{
                                    Unary: &parser.ControlUnaryExpr{
                                      Op: token.Op(token.OpNot),
                                      Primary: &parser.ControlPrimaryExpr{
                                        Nested: &parser.ControlExpr{
                                          Unary: &parser.ControlUnaryExpr{
                                            Primary: &parser.ControlPrimaryExpr{
                                              Literal: &parser.Literal{
                                                Bool: &parser.Bool(false),
                                              },
                                            },
                                          },
                                        },
                                      },
                                    },
                                  },
                                  Op: token.Op(token.OpAnd),
                                  Right: &parser.ControlExpr{
                                    Unary: &parser.ControlUnaryExpr{
                                      Primary: &parser.ControlPrimaryExpr{
                                        Literal: &parser.Literal{
                                          Bool: &parser.Bool(true),
                                        },
                                      },
                                    },
                                  },
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Nested: &parser.ControlExpr{
                                Binary: &parser.ControlBinaryExpr{
                                  Left: &parser.ControlExpr{
                                    Unary: &parser.ControlUnaryExpr{
                                      Primary: &parser.ControlPrimaryExpr{
                                        Reference: &parser.ControlReferenceExpr{
                                          Name: &"foo",
                                        },
                                      },
                                    },
                                  },
                                  Op: token.Op(token.OpAnd),
                                  Right: &parser.ControlExpr{
                                    Unary: &parser.ControlUnaryExpr{
                                      Primary: &parser.ControlPrimaryExpr{
                                        Reference: &parser.ControlReferenceExpr{
                                          Name: &"bar",
                                        },
                                      },
                                    },
                                  },
                                },
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpOr),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Nested: &parser.ControlExpr{
                                Binary: &parser.ControlBinaryExpr{
                                  Left: &parser.ControlExpr{
                                    Unary: &parser.ControlUnaryExpr{
                                      Primary: &parser.ControlPrimaryExpr{
                                        Reference: &parser.ControlReferenceExpr{
                                          Name: &"baz",
                                        },
                                      },
                                    },
                                  },
                                  Op: token.Op(token.OpEql),
                                  Right: &parser.ControlExpr{
                                    Unary: &parser.ControlUnaryExpr{
                                      Primary: &parser.ControlPrimaryExpr{
                                        Literal: &parser.Literal{
                                          Bool: &parser.Bool(true),
                                        },
                                      },
                                    },
                                  },
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    ImplicitVar: &"baz",
                  },
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"baz",
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpEql),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"bar",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Var: &parser.VarDeclStmt{
                      Dest: &parser.VariableExpr{
                        Name: &"baz",
                      },
                      Source: &parser.Expr{
                        Unary: &parser.UnaryExpr{
                          Primary: &parser.PrimaryExpr{
                            Reference: &parser.ReferenceExpr{
                              Name: &"baz",
                            },
                          },
                        },
                      },
                    },
                  },
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Binary: &parser.ControlBinaryExpr{
                            Left: &parser.ControlExpr{
                              Unary: &parser.ControlUnaryExpr{
                                Primary: &parser.ControlPrimaryExpr{
                                  Reference: &parser.ControlReferenceExpr{
                                    Name: &"foo",
                                  },
                                },
                              },
                            },
                            Op: token.Op(token.OpEql),
                            Right: &parser.ControlExpr{
                              Unary: &parser.ControlUnaryExpr{
                                Primary: &parser.ControlPrimaryExpr{
                                  Reference: &parser.ControlReferenceExpr{
                                    Name: &"bar",
                                  },
                                },
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpEql),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"baz",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Var: &parser.VarDeclStmt{
                      Dest: &parser.VariableExpr{
                        Destructuring: &parser.DestructuringExpr{
                          Names: []string{
                            "bar",
                            "baz",
                          },
                        },
                      },
                      Source: &parser.Expr{
                        Unary: &parser.UnaryExpr{
                          Primary: &parser.PrimaryExpr{
                            Reference: &parser.ReferenceExpr{
                              Name: &"foo",
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Literal: &parser.Literal{
                                Number: &"10",
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpGt),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"len",
                                KeyPath: &parser.ControlKeyPathExpr{
                                  Call: &parser.ControlCallExpr{
                                    Arguments: []*parser.ArgumentExpr{
                                      {
                                        Expr: &parser.Expr{
                                          Unary: &parser.UnaryExpr{
                                            Primary: &parser.PrimaryExpr{
                                              Reference: &parser.ReferenceExpr{
                                                Name: &"something",
                                              },
                                            },
                                          },
                                        },
                                      },
                                    },
                                  },
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Unary: &parser.ControlUnaryExpr{
                        Primary: &parser.ControlPrimaryExpr{
                          Literal: &parser.Literal{
                            Bool: &parser.Bool(true),
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"foo",
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpEql),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"bar",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"foo",
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpEql),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Literal: &parser.Literal{
                                Number: &"1",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
              ElseIfs: []*parser.ConditionalBlock{
                {
                  Fragments: []*parser.ConditionalFragment{
                    {
                      Expr: &parser.ControlExpr{
                        Binary: &parser.ControlBinaryExpr{
                          Left: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Reference: &parser.ControlReferenceExpr{
                                  Name: &"foo",
                                },
                              },
                            },
                          },
                          Op: token.Op(token.OpEql),
                          Right: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Literal: &parser.Literal{
                                  Number: &"2",
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"foo",
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpEql),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Literal: &parser.Literal{
                                Number: &"1",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
              ElseIfs: []*parser.ConditionalBlock{
                {
                  Fragments: []*parser.ConditionalFragment{
                    {
                      Expr: &parser.ControlExpr{
                        Binary: &parser.ControlBinaryExpr{
                          Left: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Reference: &parser.ControlReferenceExpr{
                                  Name: &"foo",
                                },
                              },
                            },
                          },
                          Op: token.Op(token.OpEql),
                          Right: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Literal: &parser.Literal{
                                  Number: &"2",
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
                {
                  Fragments: []*parser.ConditionalFragment{
                    {
                      Expr: &parser.ControlExpr{
                        Binary: &parser.ControlBinaryExpr{
                          Left: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Reference: &parser.ControlReferenceExpr{
                                  Name: &"foo",
                                },
                              },
                            },
                          },
                          Op: token.Op(token.OpEql),
                          Right: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Literal: &parser.Literal{
                                  Number: &"3",
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Unary: &parser.ControlUnaryExpr{
                        Primary: &parser.ControlPrimaryExpr{
                          Literal: &parser.Literal{
                            Bool: &parser.Bool(true),
                          },
                        },
                      },
                    },
                  },
                },
              },
              ElseIfs: []*parser.ConditionalBlock{
                {
                  Fragments: []*parser.ConditionalFragment{
                    {
                      Expr: &parser.ControlExpr{
                        Unary: &parser.ControlUnaryExpr{
                          Primary: &parser.ControlPrimaryExpr{
                            Literal: &parser.Literal{
                              Bool: &parser.Bool(false),
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"foo",
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpEql),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"bar",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
              ElseIfs: []*parser.ConditionalBlock{
                {
                  Fragments: []*parser.ConditionalFragment{
                    {
                      Expr: &parser.ControlExpr{
                        Binary: &parser.ControlBinaryExpr{
                          Left: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Reference: &parser.ControlReferenceExpr{
                                  Name: &"bar",
                                },
                              },
                            },
                          },
                          Op: token.Op(token.OpEql),
                          Right: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Reference: &parser.ControlReferenceExpr{
                                  Name: &"baz",
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"foo",
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpEql),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Literal: &parser.Literal{
                                Number: &"1",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
              ElseIfs: []*parser.ConditionalBlock{
                {
                  Fragments: []*parser.ConditionalFragment{
                    {
                      Expr: &parser.ControlExpr{
                        Binary: &parser.ControlBinaryExpr{
                          Left: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Reference: &parser.ControlReferenceExpr{
                                  Name: &"foo",
                                },
                              },
                            },
                          },
                          Op: token.Op(token.OpEql),
                          Right: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Literal: &parser.Literal{
                                  Number: &"2",
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
                {
                  Fragments: []*parser.ConditionalFragment{
                    {
                      Expr: &parser.ControlExpr{
                        Binary: &parser.ControlBinaryExpr{
                          Left: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Reference: &parser.ControlReferenceExpr{
                                  Name: &"foo",
                                },
                              },
                            },
                          },
                          Op: token.Op(token.OpEql),
                          Right: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Literal: &parser.Literal{
                                  Number: &"3",
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"foo",
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpAnd),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"bar",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
              ElseIfs: []*parser.ConditionalBlock{
                {
                  Fragments: []*parser.ConditionalFragment{
                    {
                      Expr: &parser.ControlExpr{
                        Binary: &parser.ControlBinaryExpr{
                          Left: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Nested: &parser.ControlExpr{
                                  Binary: &parser.ControlBinaryExpr{
                                    Left: &parser.ControlExpr{
                                      Unary: &parser.ControlUnaryExpr{
                                        Primary: &parser.ControlPrimaryExpr{
                                          Reference: &parser.ControlReferenceExpr{
                                            Name: &"foo",
                                          },
                                        },
                                      },
                                    },
                                    Op: token.Op(token.OpOr),
                                    Right: &parser.ControlExpr{
                                      Unary: &parser.ControlUnaryExpr{
                                        Primary: &parser.ControlPrimaryExpr{
                                          Reference: &parser.ControlReferenceExpr{
                                            Name: &"bar",
                                          },
                                        },
                                      },
                                    },
                                  },
                                },
                              },
                            },
                          },
                          Op: token.Op(token.OpAnd),
                          Right: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Reference: &parser.ControlReferenceExpr{
                                  Name: &"baz",
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Var: &parser.VarDeclStmt{
                      Dest: &parser.VariableExpr{
                        Name: &"x",
                      },
                      Source: &parser.Expr{
                        Unary: &parser.UnaryExpr{
                          Primary: &parser.PrimaryExpr{
                            Reference: &parser.ReferenceExpr{
                              Name: &"getValue",
                              KeyPath: &parser.KeyPathExpr{
                                Call: &parser.CallExpr{
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                  {
                    Expr: &parser.ControlExpr{
                      Binary: &parser.ControlBinaryExpr{
                        Left: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Reference: &parser.ControlReferenceExpr{
                                Name: &"x",
                              },
                            },
                          },
                        },
                        Op: token.Op(token.OpGt),
                        Right: &parser.ControlExpr{
                          Unary: &parser.ControlUnaryExpr{
                            Primary: &parser.ControlPrimaryExpr{
                              Literal: &parser.Literal{
                                Number: &"0",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
              ElseIfs: []*parser.ConditionalBlock{
                {
                  Fragments: []*parser.ConditionalFragment{
                    {
                      Var: &parser.VarDeclStmt{
                        Dest: &parser.VariableExpr{
                          Name: &"y",
                        },
                        Source: &parser.Expr{
                          Unary: &parser.UnaryExpr{
                            Primary: &parser.PrimaryExpr{
                              Reference: &parser.ReferenceExpr{
                                Name: &"getOther",
                                KeyPath: &parser.KeyPathExpr{
                                  Call: &parser.CallExpr{
                                  },
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                    {
                      Expr: &parser.ControlExpr{
                        Binary: &parser.ControlBinaryExpr{
                          Left: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Reference: &parser.ControlReferenceExpr{
                                  Name: &"y",
                                },
                              },
                            },
                          },
                          Op: token.Op(token.OpLt),
                          Right: &parser.ControlExpr{
                            Unary: &parser.ControlUnaryExpr{
                              Primary: &parser.ControlPrimaryExpr{
                                Literal: &parser.Literal{
                                  Number: &"0",
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    ImplicitVar: &"a",
                  },
                },
              },
              ElseIfs: []*parser.ConditionalBlock{
                {
                  Fragments: []*parser.ConditionalFragment{
                    {
                      Var: &parser.VarDeclStmt{
                        Dest: &parser.VariableExpr{
                          Name: &"b",
                        },
                        Source: &parser.Expr{
                          Unary: &parser.UnaryExpr{
                            Primary: &parser.PrimaryExpr{
                              Reference: &parser.ReferenceExpr{
                                Name: &"something",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              If: &parser.ConditionalBlock{
                Fragments: []*parser.ConditionalFragment{
                  {
                    Var: &parser.VarDeclStmt{
                      Dest: &parser.VariableExpr{
                        Destructuring: &parser.DestructuringExpr{
                          Names: []string{
                            "x",
                            "y",
                          },
                        },
                      },
                      Source: &parser.Expr{
                        Unary: &parser.UnaryExpr{
                          Primary: &parser.PrimaryExpr{
                            Reference: &parser.ReferenceExpr{
                              Name: &"coords",
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
              ElseIfs: []*parser.ConditionalBlock{
                {
                  Fragments: []*parser.ConditionalFragment{
                    {
                      Var: &parser.VarDeclStmt{
                        Dest: &parser.VariableExpr{
                          Name: &"z",
                        },
                        Source: &parser.Expr{
                          Unary: &parser.UnaryExpr{
                            Primary: &parser.PrimaryExpr{
                              Reference: &parser.ReferenceExpr{
                                Name: &"fallback",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    },
  },
}
