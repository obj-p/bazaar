&parser.Bazaar{
  Package: &parser.PackageDecl{
    Domain: []string{
      "optionalchaining",
    },
  },
  Decls: []*parser.TopLevelDecl{
    {
      Function: &parser.FunctionDecl{
        Name: "OptionalChaining",
        Block: []*parser.Stmt{
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"result",
              },
              Source: &parser.Expr{
                Unary: &parser.UnaryExpr{
                  Primary: &parser.PrimaryExpr{
                    Reference: &parser.ReferenceExpr{
                      Name: &"obj",
                      KeyPath: &parser.KeyPathExpr{
                        Optional: true,
                        Reference: &parser.ReferenceExpr{
                          Name: &"property",
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"method",
              },
              Source: &parser.Expr{
                Unary: &parser.UnaryExpr{
                  Primary: &parser.PrimaryExpr{
                    Reference: &parser.ReferenceExpr{
                      Name: &"obj",
                      KeyPath: &parser.KeyPathExpr{
                        Optional: true,
                        Reference: &parser.ReferenceExpr{
                          Name: &"method",
                          KeyPath: &parser.KeyPathExpr{
                            Call: &parser.CallExpr{
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"nested",
              },
              Source: &parser.Expr{
                Unary: &parser.UnaryExpr{
                  Primary: &parser.PrimaryExpr{
                    Reference: &parser.ReferenceExpr{
                      Name: &"obj",
                      KeyPath: &parser.KeyPathExpr{
                        Optional: true,
                        Reference: &parser.ReferenceExpr{
                          Name: &"nested",
                          KeyPath: &parser.KeyPathExpr{
                            Optional: true,
                            Reference: &parser.ReferenceExpr{
                              Name: &"property",
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"indexed",
              },
              Source: &parser.Expr{
                Unary: &parser.UnaryExpr{
                  Primary: &parser.PrimaryExpr{
                    Reference: &parser.ReferenceExpr{
                      Name: &"array",
                      KeyPath: &parser.KeyPathExpr{
                        Optional: true,
                        Subscript: &parser.Expr{
                          Unary: &parser.UnaryExpr{
                            Primary: &parser.PrimaryExpr{
                              Literal: &parser.Literal{
                                Number: &"0",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"deepIndexed",
              },
              Source: &parser.Expr{
                Unary: &parser.UnaryExpr{
                  Primary: &parser.PrimaryExpr{
                    Reference: &parser.ReferenceExpr{
                      Name: &"array",
                      KeyPath: &parser.KeyPathExpr{
                        Optional: true,
                        Subscript: &parser.Expr{
                          Unary: &parser.UnaryExpr{
                            Primary: &parser.PrimaryExpr{
                              Literal: &parser.Literal{
                                Number: &"0",
                              },
                            },
                          },
                        },
                        Next: &parser.KeyPathExpr{
                          Optional: true,
                          Reference: &parser.ReferenceExpr{
                            Name: &"field",
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"called",
              },
              Source: &parser.Expr{
                Unary: &parser.UnaryExpr{
                  Primary: &parser.PrimaryExpr{
                    Reference: &parser.ReferenceExpr{
                      Name: &"func",
                      KeyPath: &parser.KeyPathExpr{
                        Optional: true,
                        Call: &parser.CallExpr{
                          Arguments: []*parser.ArgumentExpr{
                            {
                              Expr: &parser.Expr{
                                Unary: &parser.UnaryExpr{
                                  Primary: &parser.PrimaryExpr{
                                    Reference: &parser.ReferenceExpr{
                                      Name: &"param",
                                    },
                                  },
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"chainedCall",
              },
              Source: &parser.Expr{
                Unary: &parser.UnaryExpr{
                  Primary: &parser.PrimaryExpr{
                    Reference: &parser.ReferenceExpr{
                      Name: &"obj",
                      KeyPath: &parser.KeyPathExpr{
                        Optional: true,
                        Reference: &parser.ReferenceExpr{
                          Name: &"method",
                          KeyPath: &parser.KeyPathExpr{
                            Call: &parser.CallExpr{
                            },
                            Next: &parser.KeyPathExpr{
                              Optional: true,
                              Reference: &parser.ReferenceExpr{
                                Name: &"result",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            If: &parser.IfStmt{
              Fragments: []*parser.IfFragment{
                {
                  Expr: &parser.Expr{
                    Unary: &parser.UnaryExpr{
                      Primary: &parser.PrimaryExpr{
                        Reference: &parser.ReferenceExpr{
                          Name: &"obj",
                          KeyPath: &parser.KeyPathExpr{
                            Optional: true,
                            Reference: &parser.ReferenceExpr{
                              Name: &"property",
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"conditional",
              },
              Source: &parser.Expr{
                Binary: &parser.BinaryExpr{
                  Left: &parser.Expr{
                    Unary: &parser.UnaryExpr{
                      Primary: &parser.PrimaryExpr{
                        Reference: &parser.ReferenceExpr{
                          Name: &"obj",
                          KeyPath: &parser.KeyPathExpr{
                            Optional: true,
                            Reference: &parser.ReferenceExpr{
                              Name: &"value",
                            },
                          },
                        },
                      },
                    },
                  },
                  Op: token.Op(token.OpGt),
                  Right: &parser.Expr{
                    Unary: &parser.UnaryExpr{
                      Primary: &parser.PrimaryExpr{
                        Literal: &parser.Literal{
                          Number: &"0",
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"complexResult",
              },
              Source: &parser.Expr{
                Unary: &parser.UnaryExpr{
                  Primary: &parser.PrimaryExpr{
                    Reference: &parser.ReferenceExpr{
                      Name: &"obj",
                      KeyPath: &parser.KeyPathExpr{
                        Optional: true,
                        Reference: &parser.ReferenceExpr{
                          Name: &"method",
                          KeyPath: &parser.KeyPathExpr{
                            Call: &parser.CallExpr{
                            },
                            Next: &parser.KeyPathExpr{
                              Optional: true,
                              Reference: &parser.ReferenceExpr{
                                Name: &"property",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"complexIndexed",
              },
              Source: &parser.Expr{
                Unary: &parser.UnaryExpr{
                  Primary: &parser.PrimaryExpr{
                    Reference: &parser.ReferenceExpr{
                      Name: &"array",
                      KeyPath: &parser.KeyPathExpr{
                        Optional: true,
                        Subscript: &parser.Expr{
                          Unary: &parser.UnaryExpr{
                            Primary: &parser.PrimaryExpr{
                              Literal: &parser.Literal{
                                Number: &"0",
                              },
                            },
                          },
                        },
                        Next: &parser.KeyPathExpr{
                          Optional: true,
                          Reference: &parser.ReferenceExpr{
                            Name: &"field",
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"complexCalled",
              },
              Source: &parser.Expr{
                Unary: &parser.UnaryExpr{
                  Primary: &parser.PrimaryExpr{
                    Reference: &parser.ReferenceExpr{
                      Name: &"func",
                      KeyPath: &parser.KeyPathExpr{
                        Optional: true,
                        Call: &parser.CallExpr{
                          Arguments: []*parser.ArgumentExpr{
                            {
                              Expr: &parser.Expr{
                                Unary: &parser.UnaryExpr{
                                  Primary: &parser.PrimaryExpr{
                                    Reference: &parser.ReferenceExpr{
                                      Name: &"param",
                                    },
                                  },
                                },
                              },
                            },
                          },
                        },
                        Next: &parser.KeyPathExpr{
                          Optional: true,
                          Reference: &parser.ReferenceExpr{
                            Name: &"result",
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"complex",
              },
              Source: &parser.Expr{
                Unary: &parser.UnaryExpr{
                  Primary: &parser.PrimaryExpr{
                    Reference: &parser.ReferenceExpr{
                      Name: &"obj",
                      KeyPath: &parser.KeyPathExpr{
                        Optional: true,
                        Reference: &parser.ReferenceExpr{
                          Name: &"arr",
                          KeyPath: &parser.KeyPathExpr{
                            Optional: true,
                            Subscript: &parser.Expr{
                              Unary: &parser.UnaryExpr{
                                Primary: &parser.PrimaryExpr{
                                  Reference: &parser.ReferenceExpr{
                                    Name: &"idx",
                                  },
                                },
                              },
                            },
                            Next: &parser.KeyPathExpr{
                              Optional: true,
                              Reference: &parser.ReferenceExpr{
                                Name: &"call",
                                KeyPath: &parser.KeyPathExpr{
                                  Call: &parser.CallExpr{
                                  },
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"mixedChain",
              },
              Source: &parser.Expr{
                Unary: &parser.UnaryExpr{
                  Primary: &parser.PrimaryExpr{
                    Reference: &parser.ReferenceExpr{
                      Name: &"items",
                      KeyPath: &parser.KeyPathExpr{
                        Optional: true,
                        Subscript: &parser.Expr{
                          Unary: &parser.UnaryExpr{
                            Primary: &parser.PrimaryExpr{
                              Literal: &parser.Literal{
                                Number: &"0",
                              },
                            },
                          },
                        },
                        Next: &parser.KeyPathExpr{
                          Optional: true,
                          Reference: &parser.ReferenceExpr{
                            Name: &"name",
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"deepChain",
              },
              Source: &parser.Expr{
                Unary: &parser.UnaryExpr{
                  Primary: &parser.PrimaryExpr{
                    Reference: &parser.ReferenceExpr{
                      Name: &"root",
                      KeyPath: &parser.KeyPathExpr{
                        Optional: true,
                        Reference: &parser.ReferenceExpr{
                          Name: &"child",
                          KeyPath: &parser.KeyPathExpr{
                            Optional: true,
                            Reference: &parser.ReferenceExpr{
                              Name: &"grandchild",
                              KeyPath: &parser.KeyPathExpr{
                                Optional: true,
                                Reference: &parser.ReferenceExpr{
                                  Name: &"value",
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"arithmetic",
              },
              Source: &parser.Expr{
                Binary: &parser.BinaryExpr{
                  Left: &parser.Expr{
                    Unary: &parser.UnaryExpr{
                      Primary: &parser.PrimaryExpr{
                        Nested: &parser.Expr{
                          Binary: &parser.BinaryExpr{
                            Left: &parser.Expr{
                              Unary: &parser.UnaryExpr{
                                Primary: &parser.PrimaryExpr{
                                  Reference: &parser.ReferenceExpr{
                                    Name: &"obj",
                                    KeyPath: &parser.KeyPathExpr{
                                      Optional: true,
                                      Reference: &parser.ReferenceExpr{
                                        Name: &"count",
                                      },
                                    },
                                  },
                                },
                              },
                            },
                            Op: token.Op(token.OpCoalesce),
                            Right: &parser.Expr{
                              Unary: &parser.UnaryExpr{
                                Primary: &parser.PrimaryExpr{
                                  Literal: &parser.Literal{
                                    Number: &"0",
                                  },
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                  Op: token.Op(token.OpAdd),
                  Right: &parser.Expr{
                    Unary: &parser.UnaryExpr{
                      Primary: &parser.PrimaryExpr{
                        Literal: &parser.Literal{
                          Number: &"1",
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          {
            Var: &parser.VarDeclStmt{
              Dest: &parser.VariableExpr{
                Name: &"chained",
              },
              Source: &parser.Expr{
                Binary: &parser.BinaryExpr{
                  Left: &parser.Expr{
                    Unary: &parser.UnaryExpr{
                      Primary: &parser.PrimaryExpr{
                        Reference: &parser.ReferenceExpr{
                          Name: &"obj",
                          KeyPath: &parser.KeyPathExpr{
                            Optional: true,
                            Reference: &parser.ReferenceExpr{
                              Name: &"value",
                            },
                          },
                        },
                      },
                    },
                  },
                  Op: token.Op(token.OpCoalesce),
                  Right: &parser.Expr{
                    Binary: &parser.BinaryExpr{
                      Left: &parser.Expr{
                        Unary: &parser.UnaryExpr{
                          Primary: &parser.PrimaryExpr{
                            Reference: &parser.ReferenceExpr{
                              Name: &"other",
                              KeyPath: &parser.KeyPathExpr{
                                Optional: true,
                                Reference: &parser.ReferenceExpr{
                                  Name: &"value",
                                },
                              },
                            },
                          },
                        },
                      },
                      Op: token.Op(token.OpCoalesce),
                      Right: &parser.Expr{
                        Unary: &parser.UnaryExpr{
                          Primary: &parser.PrimaryExpr{
                            Literal: &parser.Literal{
                              String: &parser.String{
                                Fragments: []*parser.StringFragment{
                                  {
                                    Text: &"default",
                                  },
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    },
  },
}
